//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.2.0.0 (NJsonSchema v11.1.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AccountsAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param nameOrPhone (optional) 
     * @param role (optional) 
     * @param isActive (optional) 
     * @param registerFrom (optional) 
     * @param registerTo (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllAccounts(nameOrPhone?: string | undefined, role?: UserRole | undefined, isActive?: boolean | undefined, registerFrom?: string | undefined, registerTo?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<AccountsReviewResponsePaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Accounts/getAllAccounts?";
        if (nameOrPhone === null)
            throw new Error("The parameter 'nameOrPhone' cannot be null.");
        else if (nameOrPhone !== undefined)
            url_ += "NameOrPhone=" + encodeURIComponent("" + nameOrPhone) + "&";
        if (role === null)
            throw new Error("The parameter 'role' cannot be null.");
        else if (role !== undefined)
            url_ += "Role=" + encodeURIComponent("" + role) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (registerFrom === null)
            throw new Error("The parameter 'registerFrom' cannot be null.");
        else if (registerFrom !== undefined)
            url_ += "RegisterFrom=" + encodeURIComponent("" + registerFrom) + "&";
        if (registerTo === null)
            throw new Error("The parameter 'registerTo' cannot be null.");
        else if (registerTo !== undefined)
            url_ += "RegisterTo=" + encodeURIComponent("" + registerTo) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllAccounts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllAccounts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountsReviewResponsePaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountsReviewResponsePaginationResponseResult>;
        }));
    }

    protected processGetAllAccounts(response: HttpResponseBase): Observable<AccountsReviewResponsePaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountsReviewResponsePaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getAccountById(id?: string | undefined): Observable<GetAccountByIdResponseResult> {
        let url_ = this.baseUrl + "/api/Accounts/getAccountById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAccountById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAccountById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAccountByIdResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAccountByIdResponseResult>;
        }));
    }

    protected processGetAccountById(response: HttpResponseBase): Observable<GetAccountByIdResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAccountByIdResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateAccount(body?: UpdateAccountCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Accounts/updateAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processUpdateAccount(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeActivation(body?: ChangeActivationCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Accounts/changeActivation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeActivation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeActivation(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processChangeActivation(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccount(body?: DeleteAccountCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Accounts/deleteAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    accountsDropdown(): Observable<AccountsDropdownResponseListResult> {
        let url_ = this.baseUrl + "/api/Accounts/accountsDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAccountsDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAccountsDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AccountsDropdownResponseListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AccountsDropdownResponseListResult>;
        }));
    }

    protected processAccountsDropdown(response: HttpResponseBase): Observable<AccountsDropdownResponseListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AccountsDropdownResponseListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    getBannerAds(): Observable<GetAdDtoListResult> {
        let url_ = this.baseUrl + "/api/Ad/getBannerAds";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetBannerAds(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetBannerAds(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAdDtoListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAdDtoListResult>;
        }));
    }

    protected processGetBannerAds(response: HttpResponseBase): Observable<GetAdDtoListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAdDtoListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    redirectAdClick(id: string, userId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/Ad/redirectAdClick/{id}/{userId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRedirectAdClick(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRedirectAdClick(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRedirectAdClick(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AdWebAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body?: CreateAdCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/AdWeb/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param status (optional) 
     * @param advertiserName (optional) 
     * @param locations (optional) 
     * @param userTypeTarget (optional) 
     * @param sortBy (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    get(status?: AdStatus | undefined, advertiserName?: string | undefined, locations?: string[] | undefined, userTypeTarget?: UserTypeTarget | undefined, sortBy?: AdsSortingOptions | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetAdsQueryResponsePaginationResponseResult> {
        let url_ = this.baseUrl + "/api/AdWeb/get?";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (advertiserName === null)
            throw new Error("The parameter 'advertiserName' cannot be null.");
        else if (advertiserName !== undefined)
            url_ += "AdvertiserName=" + encodeURIComponent("" + advertiserName) + "&";
        if (locations === null)
            throw new Error("The parameter 'locations' cannot be null.");
        else if (locations !== undefined)
            locations && locations.forEach(item => { url_ += "Locations=" + encodeURIComponent("" + item) + "&"; });
        if (userTypeTarget === null)
            throw new Error("The parameter 'userTypeTarget' cannot be null.");
        else if (userTypeTarget !== undefined)
            url_ += "UserTypeTarget=" + encodeURIComponent("" + userTypeTarget) + "&";
        if (sortBy === null)
            throw new Error("The parameter 'sortBy' cannot be null.");
        else if (sortBy !== undefined)
            url_ += "SortBy=" + encodeURIComponent("" + sortBy) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAdsQueryResponsePaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAdsQueryResponsePaginationResponseResult>;
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<GetAdsQueryResponsePaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAdsQueryResponsePaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    adWeb(id: string): Observable<GetAdByIdQueryResponseResult> {
        let url_ = this.baseUrl + "/api/AdWeb/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAdWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAdWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAdByIdQueryResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAdByIdQueryResponseResult>;
        }));
    }

    protected processAdWeb(response: HttpResponseBase): Observable<GetAdByIdQueryResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAdByIdQueryResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    update(body?: UpdateAdCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/AdWeb/update";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    performance(id: string): Observable<GetAdPerformanceResponseResult> {
        let url_ = this.baseUrl + "/api/AdWeb/performance/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPerformance(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPerformance(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAdPerformanceResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAdPerformanceResponseResult>;
        }));
    }

    protected processPerformance(response: HttpResponseBase): Observable<GetAdPerformanceResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAdPerformanceResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param interval (optional) 
     * @return Success
     */
    history(id?: string | undefined, interval?: PerformanceInterval | undefined): Observable<GetAdPerformanceHistoryResponseListResult> {
        let url_ = this.baseUrl + "/api/AdWeb/performance/history?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (interval === null)
            throw new Error("The parameter 'interval' cannot be null.");
        else if (interval !== undefined)
            url_ += "Interval=" + encodeURIComponent("" + interval) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAdPerformanceHistoryResponseListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAdPerformanceHistoryResponseListResult>;
        }));
    }

    protected processHistory(response: HttpResponseBase): Observable<GetAdPerformanceHistoryResponseListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetAdPerformanceHistoryResponseListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AreaOfInterestAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    areaOfInterest(): Observable<AreaOfInterestDropdownResponseListResult> {
        let url_ = this.baseUrl + "/api/AreaOfInterest/areaOfInterest";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAreaOfInterest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAreaOfInterest(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaOfInterestDropdownResponseListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaOfInterestDropdownResponseListResult>;
        }));
    }

    protected processAreaOfInterest(response: HttpResponseBase): Observable<AreaOfInterestDropdownResponseListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AreaOfInterestDropdownResponseListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    areaOfInterestWebDropdown(): Observable<AreaOfInterestWebDropdownResponseListResult> {
        let url_ = this.baseUrl + "/api/AreaOfInterest/areaOfInterestWebDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAreaOfInterestWebDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAreaOfInterestWebDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AreaOfInterestWebDropdownResponseListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AreaOfInterestWebDropdownResponseListResult>;
        }));
    }

    protected processAreaOfInterestWebDropdown(response: HttpResponseBase): Observable<AreaOfInterestWebDropdownResponseListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AreaOfInterestWebDropdownResponseListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class AuthAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    loginAdmin(body?: LoginAdminCommand | undefined): Observable<TokenDtoResult> {
        let url_ = this.baseUrl + "/api/Auth/loginAdmin";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginAdmin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDtoResult>;
        }));
    }

    protected processLoginAdmin(response: HttpResponseBase): Observable<TokenDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    loginUser(body?: LoginUserCommand | undefined): Observable<TokenDtoResult> {
        let url_ = this.baseUrl + "/api/Auth/loginUser";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLoginUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLoginUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDtoResult>;
        }));
    }

    protected processLoginUser(response: HttpResponseBase): Observable<TokenDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    refreshToken(body?: RefreshTokenCommand | undefined): Observable<TokenDtoResult> {
        let url_ = this.baseUrl + "/api/Auth/refreshToken";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshToken(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshToken(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<TokenDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<TokenDtoResult>;
        }));
    }

    protected processRefreshToken(response: HttpResponseBase): Observable<TokenDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    register(body?: RegistrationCommand | undefined): Observable<RegisterCommandResponseResult> {
        let url_ = this.baseUrl + "/api/Auth/register";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRegister(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRegister(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RegisterCommandResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RegisterCommandResponseResult>;
        }));
    }

    protected processRegister(response: HttpResponseBase): Observable<RegisterCommandResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RegisterCommandResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommentAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createComment(body?: CreateCommentCommand | undefined): Observable<MobileCommentWithRepliesDtoResult> {
        let url_ = this.baseUrl + "/api/Comment/createComment";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MobileCommentWithRepliesDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MobileCommentWithRepliesDtoResult>;
        }));
    }

    protected processCreateComment(response: HttpResponseBase): Observable<MobileCommentWithRepliesDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MobileCommentWithRepliesDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReply(body?: CreateReplyCommand | undefined): Observable<MobileCommentDtoResult> {
        let url_ = this.baseUrl + "/api/Comment/createReply";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReply(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReply(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MobileCommentDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MobileCommentDtoResult>;
        }));
    }

    protected processCreateReply(response: HttpResponseBase): Observable<MobileCommentDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MobileCommentDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param commentId (optional) 
     * @return Success
     */
    deleteComment(commentId?: string | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Comment/deleteComment?";
        if (commentId === null)
            throw new Error("The parameter 'commentId' cannot be null.");
        else if (commentId !== undefined)
            url_ += "CommentId=" + encodeURIComponent("" + commentId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteComment(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteComment(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processDeleteComment(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param propertyId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getComments(propertyId?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<MobileCommentWithRepliesDtoPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Comment/getComments?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MobileCommentWithRepliesDtoPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MobileCommentWithRepliesDtoPaginationResponseResult>;
        }));
    }

    protected processGetComments(response: HttpResponseBase): Observable<MobileCommentWithRepliesDtoPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MobileCommentWithRepliesDtoPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CommentWebAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param propertyId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getComments(propertyId?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<WebCommentWithRepliesDtoPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/CommentWeb/getComments?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetComments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetComments(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<WebCommentWithRepliesDtoPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<WebCommentWithRepliesDtoPaginationResponseResult>;
        }));
    }

    protected processGetComments(response: HttpResponseBase): Observable<WebCommentWithRepliesDtoPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as WebCommentWithRepliesDtoPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CouponAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param code (optional) 
     * @param package_Id (optional) 
     * @return Success
     */
    verify(code?: string | undefined, package_Id?: string | undefined): Observable<DecimalResult> {
        let url_ = this.baseUrl + "/api/Coupon/verify?";
        if (code === null)
            throw new Error("The parameter 'code' cannot be null.");
        else if (code !== undefined)
            url_ += "Code=" + encodeURIComponent("" + code) + "&";
        if (package_Id === null)
            throw new Error("The parameter 'package_Id' cannot be null.");
        else if (package_Id !== undefined)
            url_ += "Package_Id=" + encodeURIComponent("" + package_Id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerify(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerify(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DecimalResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DecimalResult>;
        }));
    }

    protected processVerify(response: HttpResponseBase): Observable<DecimalResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DecimalResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class CouponWebAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body?: CreateCouponCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/CouponWeb/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DepositAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createDeposit(body?: SendDepositCommand | undefined): Observable<DepositDtoResult> {
        let url_ = this.baseUrl + "/api/Deposit/CreateDeposit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositDtoResult>;
        }));
    }

    protected processCreateDeposit(response: HttpResponseBase): Observable<DepositDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DepositDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    acceptDeposit(body?: AcceptDepositCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Deposit/AcceptDeposit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAcceptDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAcceptDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processAcceptDeposit(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    rejectDeposit(body?: RejectDepositCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Deposit/RejectDeposit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processRejectDeposit(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteDeposit(body?: DeleteDepositCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Deposit/DeleteDeposit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processDeleteDeposit(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    updateDeposit(body?: UpdateDepositCommand | undefined): Observable<DepositDtoResult> {
        let url_ = this.baseUrl + "/api/Deposit/UpdateDeposit";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeposit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeposit(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositDtoResult>;
        }));
    }

    protected processUpdateDeposit(response: HttpResponseBase): Observable<DepositDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DepositDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getReceivedDeposits(pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetReceivedDepositsResponsePaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Deposit/GetReceivedDeposits?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReceivedDeposits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReceivedDeposits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetReceivedDepositsResponsePaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetReceivedDepositsResponsePaginationResponseResult>;
        }));
    }

    protected processGetReceivedDeposits(response: HttpResponseBase): Observable<GetReceivedDepositsResponsePaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetReceivedDepositsResponsePaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getSentDeposits(pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetSentDepositsResponsePaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Deposit/GetSentDeposits?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSentDeposits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSentDeposits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSentDepositsResponsePaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSentDepositsResponsePaginationResponseResult>;
        }));
    }

    protected processGetSentDeposits(response: HttpResponseBase): Observable<GetSentDepositsResponsePaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetSentDepositsResponsePaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class DepositWebAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param propertyId (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getPropertyDeposits(propertyId?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<DepositDtoPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/DepositWeb/GetPropertyDeposits?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyDeposits(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyDeposits(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<DepositDtoPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<DepositDtoPaginationResponseResult>;
        }));
    }

    protected processGetPropertyDeposits(response: HttpResponseBase): Observable<DepositDtoPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DepositDtoPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class FilesAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param files (optional) 
     * @return Success
     */
    upload(files?: FileParameter[] | undefined): Observable<StringListResult> {
        let url_ = this.baseUrl + "/api/Files/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (files === null || files === undefined)
            throw new Error("The parameter 'files' cannot be null.");
        else
            files.forEach(item_ => content_.append("Files", item_.data, item_.fileName ? item_.fileName : "Files") );

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringListResult>;
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<StringListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GroupAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param title (optional) 
     * @param status (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getMyGroups(title?: string | undefined, status?: GroupStatus | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetGroupBasicDtoPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Group/GetMyGroups?";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGroupBasicDtoPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGroupBasicDtoPaginationResponseResult>;
        }));
    }

    protected processGetMyGroups(response: HttpResponseBase): Observable<GetGroupBasicDtoPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetGroupBasicDtoPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getGroupById(id?: string | undefined): Observable<GetGroupDetailDtoResult> {
        let url_ = this.baseUrl + "/api/Group/GetGroupById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetGroupById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetGroupById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGroupDetailDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGroupDetailDtoResult>;
        }));
    }

    protected processGetGroupById(response: HttpResponseBase): Observable<GetGroupDetailDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetGroupDetailDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    exitGroup(body?: ExitGroupCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Group/ExitGroup";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExitGroup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExitGroup(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processExitGroup(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class GroupWebAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param title (optional) 
     * @param status (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getAllGroups(title?: string | undefined, status?: GroupStatus | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetGroupBasicDtoPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/GroupWeb/getAllGroups?";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllGroups(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllGroups(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetGroupBasicDtoPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetGroupBasicDtoPaginationResponseResult>;
        }));
    }

    protected processGetAllGroups(response: HttpResponseBase): Observable<GetGroupBasicDtoPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetGroupBasicDtoPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class NotaryAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    getNotaries(): Observable<GetNotariesQueryResponseListResult> {
        let url_ = this.baseUrl + "/api/Notary/getNotaries";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotaries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetNotariesQueryResponseListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetNotariesQueryResponseListResult>;
        }));
    }

    protected processGetNotaries(response: HttpResponseBase): Observable<GetNotariesQueryResponseListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetNotariesQueryResponseListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editNotaries(body?: EditNotaryCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Notary/editNotaries";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditNotaries(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditNotaries(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processEditNotaries(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class OTPAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    sendOTP(body?: SendOTPCommand | undefined): Observable<SendOTPCommandResponseResult> {
        let url_ = this.baseUrl + "/api/OTP/SendOTP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSendOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSendOTP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SendOTPCommandResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SendOTPCommandResponseResult>;
        }));
    }

    protected processSendOTP(response: HttpResponseBase): Observable<SendOTPCommandResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as SendOTPCommandResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    verifyOTP(body?: VerifyOTPCommand | undefined): Observable<VerifyOTPResponseResult> {
        let url_ = this.baseUrl + "/api/OTP/verifyOTP";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processVerifyOTP(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processVerifyOTP(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<VerifyOTPResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<VerifyOTPResponseResult>;
        }));
    }

    protected processVerifyOTP(response: HttpResponseBase): Observable<VerifyOTPResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as VerifyOTPResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PackageAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    getPackages(): Observable<GetPackagesResponseListResult> {
        let url_ = this.baseUrl + "/api/Package/getPackages";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPackages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPackages(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPackagesResponseListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPackagesResponseListResult>;
        }));
    }

    protected processGetPackages(response: HttpResponseBase): Observable<GetPackagesResponseListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPackagesResponseListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PackageWebAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    create(body?: CreatePackageCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/PackageWeb/create";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PostAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param name (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getPropertyTypes(name?: string | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetPropertyTypeDtoPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Post/getPropertyTypes?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPropertyTypeDtoPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPropertyTypeDtoPaginationResponseResult>;
        }));
    }

    protected processGetPropertyTypes(response: HttpResponseBase): Observable<GetPropertyTypeDtoPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPropertyTypeDtoPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param propertyTypeId (optional) 
     * @return Success
     */
    getPropertyTypeFields(propertyTypeId?: string | undefined): Observable<GetPropertyFieldDtoListResult> {
        let url_ = this.baseUrl + "/api/Post/getPropertyTypeFields?";
        if (propertyTypeId === null)
            throw new Error("The parameter 'propertyTypeId' cannot be null.");
        else if (propertyTypeId !== undefined)
            url_ += "PropertyTypeId=" + encodeURIComponent("" + propertyTypeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyTypeFields(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyTypeFields(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPropertyFieldDtoListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPropertyFieldDtoListResult>;
        }));
    }

    protected processGetPropertyTypeFields(response: HttpResponseBase): Observable<GetPropertyFieldDtoListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPropertyFieldDtoListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPost(body?: CreatePostCommand | undefined): Observable<GetPostDetailDtoResult> {
        let url_ = this.baseUrl + "/api/Post/createPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostDetailDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostDetailDtoResult>;
        }));
    }

    protected processCreatePost(response: HttpResponseBase): Observable<GetPostDetailDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPostDetailDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    getPostById(id?: string | undefined): Observable<GetPostDetailDtoResult> {
        let url_ = this.baseUrl + "/api/Post/getPostById?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostDetailDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostDetailDtoResult>;
        }));
    }

    protected processGetPostById(response: HttpResponseBase): Observable<GetPostDetailDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPostDetailDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editPost(body?: EditPostCommand | undefined): Observable<GetPostDetailDtoResult> {
        let url_ = this.baseUrl + "/api/Post/editPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostDetailDtoResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostDetailDtoResult>;
        }));
    }

    protected processEditPost(response: HttpResponseBase): Observable<GetPostDetailDtoResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPostDetailDtoResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    deletePost(id?: string | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Post/deletePost?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeletePost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeletePost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processDeletePost(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPropertyFilter(): Observable<GetPropertyFilterResponseListResult> {
        let url_ = this.baseUrl + "/api/Post/getPropertyFilter";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPropertyFilter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPropertyFilter(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPropertyFilterResponseListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPropertyFilterResponseListResult>;
        }));
    }

    protected processGetPropertyFilter(response: HttpResponseBase): Observable<GetPropertyFilterResponseListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPropertyFilterResponseListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    toggleSavedPost(body?: ToggleSavedPostCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Post/toggleSavedPost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processToggleSavedPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processToggleSavedPost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processToggleSavedPost(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createReport(body?: CreateReportCommand | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/Post/createReport";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateReport(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateReport(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringResult>;
        }));
    }

    protected processCreateReport(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createRepost(body?: CreateRepostCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Post/createRepost";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateRepost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateRepost(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processCreateRepost(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getHomePosts(body?: GetHomePostsQuery | undefined): Observable<IHomePageItemPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Post/getHomePosts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHomePosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHomePosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<IHomePageItemPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<IHomePageItemPaginationResponseResult>;
        }));
    }

    protected processGetHomePosts(response: HttpResponseBase): Observable<IHomePageItemPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as IHomePageItemPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMyPosts(body?: GetMyPostsQuery | undefined): Observable<GetPostBasicDtoPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Post/getMyPosts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMyPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMyPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostBasicDtoPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostBasicDtoPaginationResponseResult>;
        }));
    }

    protected processGetMyPosts(response: HttpResponseBase): Observable<GetPostBasicDtoPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPostBasicDtoPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getMySavedPosts(body?: GetMySavedPostsQuery | undefined): Observable<GetPostBasicDtoPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Post/getMySavedPosts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMySavedPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMySavedPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostBasicDtoPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostBasicDtoPaginationResponseResult>;
        }));
    }

    protected processGetMySavedPosts(response: HttpResponseBase): Observable<GetPostBasicDtoPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPostBasicDtoPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    getUserPosts(body?: GetUserPostQuery | undefined): Observable<GetPostBasicDtoPaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Post/getUserPosts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostBasicDtoPaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostBasicDtoPaginationResponseResult>;
        }));
    }

    protected processGetUserPosts(response: HttpResponseBase): Observable<GetPostBasicDtoPaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPostBasicDtoPaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PostWebAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param posterId (optional) 
     * @param title (optional) 
     * @param status (optional) 
     * @param propertyTypeName (optional) 
     * @param price_Min (optional) 
     * @param price_Max (optional) 
     * @param area_Min (optional) 
     * @param area_Max (optional) 
     * @param provinceIds (optional) 
     * @param sortingOption (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getPosts(posterId?: string | undefined, title?: string | undefined, status?: PropertyStatus | undefined, propertyTypeName?: string | undefined, price_Min?: number | undefined, price_Max?: number | undefined, area_Min?: number | undefined, area_Max?: number | undefined, provinceIds?: string[] | undefined, sortingOption?: SortingOptions | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetPostsResponsePaginationResponseResult> {
        let url_ = this.baseUrl + "/api/PostWeb/getPosts?";
        if (posterId === null)
            throw new Error("The parameter 'posterId' cannot be null.");
        else if (posterId !== undefined)
            url_ += "PosterId=" + encodeURIComponent("" + posterId) + "&";
        if (title === null)
            throw new Error("The parameter 'title' cannot be null.");
        else if (title !== undefined)
            url_ += "Title=" + encodeURIComponent("" + title) + "&";
        if (status === null)
            throw new Error("The parameter 'status' cannot be null.");
        else if (status !== undefined)
            url_ += "Status=" + encodeURIComponent("" + status) + "&";
        if (propertyTypeName === null)
            throw new Error("The parameter 'propertyTypeName' cannot be null.");
        else if (propertyTypeName !== undefined)
            url_ += "PropertyTypeName=" + encodeURIComponent("" + propertyTypeName) + "&";
        if (price_Min === null)
            throw new Error("The parameter 'price_Min' cannot be null.");
        else if (price_Min !== undefined)
            url_ += "Price.Min=" + encodeURIComponent("" + price_Min) + "&";
        if (price_Max === null)
            throw new Error("The parameter 'price_Max' cannot be null.");
        else if (price_Max !== undefined)
            url_ += "Price.Max=" + encodeURIComponent("" + price_Max) + "&";
        if (area_Min === null)
            throw new Error("The parameter 'area_Min' cannot be null.");
        else if (area_Min !== undefined)
            url_ += "Area.Min=" + encodeURIComponent("" + area_Min) + "&";
        if (area_Max === null)
            throw new Error("The parameter 'area_Max' cannot be null.");
        else if (area_Max !== undefined)
            url_ += "Area.Max=" + encodeURIComponent("" + area_Max) + "&";
        if (provinceIds === null)
            throw new Error("The parameter 'provinceIds' cannot be null.");
        else if (provinceIds !== undefined)
            provinceIds && provinceIds.forEach(item => { url_ += "ProvinceIds=" + encodeURIComponent("" + item) + "&"; });
        if (sortingOption === null)
            throw new Error("The parameter 'sortingOption' cannot be null.");
        else if (sortingOption !== undefined)
            url_ += "SortingOption=" + encodeURIComponent("" + sortingOption) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostsResponsePaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostsResponsePaginationResponseResult>;
        }));
    }

    protected processGetPosts(response: HttpResponseBase): Observable<GetPostsResponsePaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPostsResponsePaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    postWeb(id: string): Observable<GetPostDetailsResponseResult> {
        let url_ = this.baseUrl + "/api/PostWeb/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostWeb(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostWeb(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostDetailsResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostDetailsResponseResult>;
        }));
    }

    protected processPostWeb(response: HttpResponseBase): Observable<GetPostDetailsResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPostDetailsResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manageOfferStatus(body?: ManageOfferStatusCommand | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/PostWeb/manageOfferStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManageOfferStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManageOfferStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringResult>;
        }));
    }

    protected processManageOfferStatus(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param isResolved (optional) 
     * @param reportDate (optional) 
     * @param reporter (optional) 
     * @param oldest (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getReports(isResolved?: boolean | undefined, reportDate?: string | undefined, reporter?: string | undefined, oldest?: boolean | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetReportsResponsePaginationResponseResult> {
        let url_ = this.baseUrl + "/api/PostWeb/getReports?";
        if (isResolved === null)
            throw new Error("The parameter 'isResolved' cannot be null.");
        else if (isResolved !== undefined)
            url_ += "IsResolved=" + encodeURIComponent("" + isResolved) + "&";
        if (reportDate === null)
            throw new Error("The parameter 'reportDate' cannot be null.");
        else if (reportDate !== undefined)
            url_ += "ReportDate=" + encodeURIComponent("" + reportDate) + "&";
        if (reporter === null)
            throw new Error("The parameter 'reporter' cannot be null.");
        else if (reporter !== undefined)
            url_ += "Reporter=" + encodeURIComponent("" + reporter) + "&";
        if (oldest === null)
            throw new Error("The parameter 'oldest' cannot be null.");
        else if (oldest !== undefined)
            url_ += "Oldest=" + encodeURIComponent("" + oldest) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetReports(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetReports(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetReportsResponsePaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetReportsResponsePaginationResponseResult>;
        }));
    }

    protected processGetReports(response: HttpResponseBase): Observable<GetReportsResponsePaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetReportsResponsePaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    manageReportStatus(body?: ManageReportStatusCommand | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/PostWeb/manageReportStatus";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processManageReportStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processManageReportStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringResult>;
        }));
    }

    protected processManageReportStatus(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    getPostTree(id: string): Observable<GetPostTreeResponseResult> {
        let url_ = this.baseUrl + "/api/PostWeb/getPostTree/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPostTree(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPostTree(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPostTreeResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPostTreeResponseResult>;
        }));
    }

    protected processGetPostTree(response: HttpResponseBase): Observable<GetPostTreeResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPostTreeResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PromotionAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createPromotion(body?: CreatePromotionCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Promotion/createPromotion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreatePromotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreatePromotion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processCreatePromotion(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @return Success
     */
    stopPromotion(id?: string | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/Promotion/stopPromotion?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processStopPromotion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processStopPromotion(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringResult>;
        }));
    }

    protected processStopPromotion(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    myPromotedPosts(pageNumber?: number | undefined, pageSize?: number | undefined): Observable<MyPromotedPostsResponsePaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Promotion/MyPromotedPosts?";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processMyPromotedPosts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processMyPromotedPosts(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<MyPromotedPostsResponsePaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<MyPromotedPostsResponsePaginationResponseResult>;
        }));
    }

    protected processMyPromotedPosts(response: HttpResponseBase): Observable<MyPromotedPostsResponsePaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as MyPromotedPostsResponsePaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param id (optional) 
     * @param promotionSortOptions (optional) 
     * @param statusFilter (optional) 
     * @return Success
     */
    postPromotions(id?: string | undefined, promotionSortOptions?: PromotionSortOptions | undefined, statusFilter?: boolean | undefined): Observable<PostPromotionsResponseResult> {
        let url_ = this.baseUrl + "/api/Promotion/PostPromotions?";
        if (id === null)
            throw new Error("The parameter 'id' cannot be null.");
        else if (id !== undefined)
            url_ += "Id=" + encodeURIComponent("" + id) + "&";
        if (promotionSortOptions === null)
            throw new Error("The parameter 'promotionSortOptions' cannot be null.");
        else if (promotionSortOptions !== undefined)
            url_ += "PromotionSortOptions=" + encodeURIComponent("" + promotionSortOptions) + "&";
        if (statusFilter === null)
            throw new Error("The parameter 'statusFilter' cannot be null.");
        else if (statusFilter !== undefined)
            url_ += "StatusFilter=" + encodeURIComponent("" + statusFilter) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPostPromotions(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPostPromotions(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PostPromotionsResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PostPromotionsResponseResult>;
        }));
    }

    protected processPostPromotions(response: HttpResponseBase): Observable<PostPromotionsResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PostPromotionsResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class PropertyAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    createProperty(body?: CreatePropertyTypeCommand | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/Property/CreateProperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringResult>;
        }));
    }

    protected processCreateProperty(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteProperty(body?: DeletePropertyCommand | undefined): Observable<BooleanResult> {
        let url_ = this.baseUrl + "/api/Property/DeleteProperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResult>;
        }));
    }

    protected processDeleteProperty(response: HttpResponseBase): Observable<BooleanResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    changeActivationProperty(body?: ChangeActivationPropertyCommand | undefined): Observable<BooleanResult> {
        let url_ = this.baseUrl + "/api/Property/ChangeActivationProperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processChangeActivationProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processChangeActivationProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<BooleanResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<BooleanResult>;
        }));
    }

    protected processChangeActivationProperty(response: HttpResponseBase): Observable<BooleanResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BooleanResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param name (optional) 
     * @param orderByAlphabet (optional) 
     * @param orderByOffersCount (optional) 
     * @param orderByCreatedOn (optional) 
     * @param orderByActive (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    propertyTypes(name?: string | undefined, orderByAlphabet?: boolean | undefined, orderByOffersCount?: boolean | undefined, orderByCreatedOn?: boolean | undefined, orderByActive?: boolean | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetPropertyTypesWebQueryResponsePaginationResponseResult> {
        let url_ = this.baseUrl + "/api/Property/propertyTypes?";
        if (name === null)
            throw new Error("The parameter 'name' cannot be null.");
        else if (name !== undefined)
            url_ += "Name=" + encodeURIComponent("" + name) + "&";
        if (orderByAlphabet === null)
            throw new Error("The parameter 'orderByAlphabet' cannot be null.");
        else if (orderByAlphabet !== undefined)
            url_ += "OrderByAlphabet=" + encodeURIComponent("" + orderByAlphabet) + "&";
        if (orderByOffersCount === null)
            throw new Error("The parameter 'orderByOffersCount' cannot be null.");
        else if (orderByOffersCount !== undefined)
            url_ += "OrderByOffersCount=" + encodeURIComponent("" + orderByOffersCount) + "&";
        if (orderByCreatedOn === null)
            throw new Error("The parameter 'orderByCreatedOn' cannot be null.");
        else if (orderByCreatedOn !== undefined)
            url_ += "OrderByCreatedOn=" + encodeURIComponent("" + orderByCreatedOn) + "&";
        if (orderByActive === null)
            throw new Error("The parameter 'orderByActive' cannot be null.");
        else if (orderByActive !== undefined)
            url_ += "OrderByActive=" + encodeURIComponent("" + orderByActive) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPropertyTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPropertyTypes(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPropertyTypesWebQueryResponsePaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPropertyTypesWebQueryResponsePaginationResponseResult>;
        }));
    }

    protected processPropertyTypes(response: HttpResponseBase): Observable<GetPropertyTypesWebQueryResponsePaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPropertyTypesWebQueryResponsePaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param propertyId (optional) 
     * @return Success
     */
    propertyTypeById(propertyId?: string | undefined): Observable<GetPropertyByIdQueryResponseResult> {
        let url_ = this.baseUrl + "/api/Property/propertyTypeById?";
        if (propertyId === null)
            throw new Error("The parameter 'propertyId' cannot be null.");
        else if (propertyId !== undefined)
            url_ += "PropertyId=" + encodeURIComponent("" + propertyId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPropertyTypeById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPropertyTypeById(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetPropertyByIdQueryResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetPropertyByIdQueryResponseResult>;
        }));
    }

    protected processPropertyTypeById(response: HttpResponseBase): Observable<GetPropertyByIdQueryResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetPropertyByIdQueryResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editProperty(body?: EditPropertyCommand | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/Property/editProperty";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProperty(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProperty(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringResult>;
        }));
    }

    protected processEditProperty(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @return Success
     */
    propertyTypesDropdown(): Observable<PropertyTypesDropdownResponseListResult> {
        let url_ = this.baseUrl + "/api/Property/propertyTypesDropdown";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPropertyTypesDropdown(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPropertyTypesDropdown(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PropertyTypesDropdownResponseListResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PropertyTypesDropdownResponseListResult>;
        }));
    }

    protected processPropertyTypesDropdown(response: HttpResponseBase): Observable<PropertyTypesDropdownResponseListResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PropertyTypesDropdownResponseListResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class ResetPasswordAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    resetPassword(body?: ResetPasswordCommand | undefined): Observable<StringResult> {
        let url_ = this.baseUrl + "/api/ResetPassword/resetPassword";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<StringResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<StringResult>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<StringResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StringResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SubscriptionAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    subscribe(body?: SubscribeCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/Subscription/subscribe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubscribe(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubscribe(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processSubscribe(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class SubscriptionWebAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @param packageType (optional) 
     * @param isActive (optional) 
     * @param autoRenewal (optional) 
     * @param sortBySubscriptionDate (optional) 
     * @param sortByExpiryDate (optional) 
     * @param pageNumber (optional) 
     * @param pageSize (optional) 
     * @return Success
     */
    getSubscribedUsers(packageType?: PackageType | undefined, isActive?: boolean | undefined, autoRenewal?: boolean | undefined, sortBySubscriptionDate?: SortOrder | undefined, sortByExpiryDate?: SortOrder | undefined, pageNumber?: number | undefined, pageSize?: number | undefined): Observable<GetSubscribedUsersResponsePaginationResponseResult> {
        let url_ = this.baseUrl + "/api/SubscriptionWeb/getSubscribedUsers?";
        if (packageType === null)
            throw new Error("The parameter 'packageType' cannot be null.");
        else if (packageType !== undefined)
            url_ += "PackageType=" + encodeURIComponent("" + packageType) + "&";
        if (isActive === null)
            throw new Error("The parameter 'isActive' cannot be null.");
        else if (isActive !== undefined)
            url_ += "IsActive=" + encodeURIComponent("" + isActive) + "&";
        if (autoRenewal === null)
            throw new Error("The parameter 'autoRenewal' cannot be null.");
        else if (autoRenewal !== undefined)
            url_ += "AutoRenewal=" + encodeURIComponent("" + autoRenewal) + "&";
        if (sortBySubscriptionDate === null)
            throw new Error("The parameter 'sortBySubscriptionDate' cannot be null.");
        else if (sortBySubscriptionDate !== undefined)
            url_ += "SortBySubscriptionDate=" + encodeURIComponent("" + sortBySubscriptionDate) + "&";
        if (sortByExpiryDate === null)
            throw new Error("The parameter 'sortByExpiryDate' cannot be null.");
        else if (sortByExpiryDate !== undefined)
            url_ += "SortByExpiryDate=" + encodeURIComponent("" + sortByExpiryDate) + "&";
        if (pageNumber === null)
            throw new Error("The parameter 'pageNumber' cannot be null.");
        else if (pageNumber !== undefined)
            url_ += "PageNumber=" + encodeURIComponent("" + pageNumber) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSubscribedUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSubscribedUsers(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetSubscribedUsersResponsePaginationResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetSubscribedUsersResponsePaginationResponseResult>;
        }));
    }

    protected processGetSubscribedUsers(response: HttpResponseBase): Observable<GetSubscribedUsersResponsePaginationResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as GetSubscribedUsersResponsePaginationResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    extendSubscription(body?: ExtendSubscriptionCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/SubscriptionWeb/extendSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtendSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtendSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processExtendSubscription(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    cancelSubscription(body?: CancelSubscriptionCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/SubscriptionWeb/cancelSubscription";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelSubscription(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelSubscription(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processCancelSubscription(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

@Injectable()
export class UserAPI {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    /**
     * @return Success
     */
    getUser(): Observable<UserProfileResponseResult> {
        let url_ = this.baseUrl + "/api/User/getUser";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "text/plain"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UserProfileResponseResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UserProfileResponseResult>;
        }));
    }

    protected processGetUser(response: HttpResponseBase): Observable<UserProfileResponseResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UserProfileResponseResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    editProfile(body?: EditProfileCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/User/editProfile";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEditProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEditProfile(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processEditProfile(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    /**
     * @param body (optional) 
     * @return Success
     */
    deleteAccount(body?: DeleteUserAccountCommand | undefined): Observable<UnitResult> {
        let url_ = this.baseUrl + "/api/User/deleteAccount";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "text/plain"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteAccount(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteAccount(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<UnitResult>;
                }
            } else
                return _observableThrow(response_) as any as Observable<UnitResult>;
        }));
    }

    protected processDeleteAccount(response: HttpResponseBase): Observable<UnitResult> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnitResult;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface AcceptDepositCommand {
    id: string;
}

export interface AccountsDropdownResponse {
    id: string;
    name: string;
    phone: string;
}

export interface AccountsDropdownResponseListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: AccountsDropdownResponse[] | undefined;
}

export interface AccountsReviewResponse {
    id: string;
    role: string;
    fullName: string;
    phoneNumber: string;
    falLicense: string | undefined;
    idCard: string | undefined;
    commercialRegistrationNumber: string | undefined;
    isActive: boolean;
    createdAt: string;
}

export interface AccountsReviewResponsePaginationResponse {
    count: number;
    data: AccountsReviewResponse[] | undefined;
}

export interface AccountsReviewResponsePaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: AccountsReviewResponsePaginationResponse;
}

export interface AdMetricDto {
    marketer: number;
    nonMarketer: number;
}

export type AdPlacement = 0 | 1;

export interface AdProvinceDto {
    id: string;
    nameEn: string;
    nameAr: string;
}

export type AdStatus = 0 | 1 | 2 | 3 | 4;

export type AdsSortingOptions = 0 | 1;

export interface AdvertiserDto {
    name: string;
    email: string;
    phoneNumber: string;
}

export interface AreaOfInterestDropdownResponse {
    id: string;
    name: string;
    provinces: ProvinceDto[] | undefined;
}

export interface AreaOfInterestDropdownResponseListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: AreaOfInterestDropdownResponse[] | undefined;
}

export interface AreaOfInterestWebDropdownResponse {
    id: string;
    nameEn: string;
    nameAr: string;
    provinces: ProvinceWebDto[] | undefined;
}

export interface AreaOfInterestWebDropdownResponseListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: AreaOfInterestWebDropdownResponse[] | undefined;
}

export interface BooleanResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: boolean;
}

export interface CancelSubscriptionCommand {
    subscriptionId: string;
}

export interface ChangeActivationCommand {
    userId: string;
}

export interface ChangeActivationPropertyCommand {
    id: string;
}

export interface CommenterDto {
    id: string;
    fullName: string;
    phoneNumber: string | undefined;
}

export interface CreateAdCommand {
    title: string;
    description: string | undefined;
    advertiser: AdvertiserDto;
    adPlacement: AdPlacement;
    image: string;
    url: string;
    startDate: string;
    endDate: string;
    userTypeTarget: UserTypeTarget;
    provinces: string[] | undefined;
}

export interface CreateCommentCommand {
    propertyId: string;
    comment: string | undefined;
}

export interface CreateCouponCommand {
    code: string | undefined;
    type: DiscountType;
    discount: number;
    packageId: string;
    maxUse: number | undefined;
    newUserOnly: boolean;
    startDate: string;
    endDate: string;
    usagePerUser: number;
}

export interface CreatePackageCommand {
    name: string | undefined;
    description: string | undefined;
    price: number;
    monthlyDuration: number | undefined;
    isActive: boolean;
    postsPerMonth: number;
    hasTrustedBadge: boolean;
    showPromotionAnalytics: boolean;
    repostsPerMonth: number;
    promotionCredits: number;
    autoRenewal: boolean;
}

export interface CreatePostCommand {
    title: string | undefined;
    property: CreatePropertyCommand;
}

export interface CreatePromotionCommand {
    postId: string;
    title: string | undefined;
    startDate: string;
    numberOfDays: number;
}

export interface CreatePropertyCommand {
    posterType: PosterType;
    propertyTypeId: string;
    googleMapsLocation: GoogleMapsLocation;
    provinceId: string;
    area: number;
    price: number;
    negotiable: boolean;
    propertyDeed: string | undefined;
    ownersIdImage: string | undefined;
    agentsIdImage: string | undefined;
    powerOfAttorneyImage: string | undefined;
    images: string[] | undefined;
    propertyFieldValues: CreatePropertyFieldValueCommand[] | undefined;
}

export interface CreatePropertyFieldValueCommand {
    id: string;
    value: any | undefined;
}

export interface CreatePropertyTypeCommand {
    name_En: string;
    name_Ar: string;
    icon: string;
    description_En: string | undefined;
    description_Ar: string | undefined;
    is_Active: boolean;
    propertyFields: PropertyFieldsDto[] | undefined;
}

export interface CreateReplyCommand {
    commentId: string;
    reply: string | undefined;
}

export interface CreateReportCommand {
    postId: string;
    reason: string | undefined;
}

export interface CreateRepostCommand {
    title: string | undefined;
    postId: string;
}

export interface DateTimeNullableRangeFilter {
    min: string | undefined;
    max: string | undefined;
}

export interface DecimalNullableRangeFilter {
    min: number | undefined;
    max: number | undefined;
}

export interface DecimalResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: number;
}

export interface DeleteAccountCommand {
    userId: string;
}

export interface DeleteDepositCommand {
    id: string;
}

export interface DeletePropertyCommand {
    id: string;
}

export interface DeleteUserAccountCommand {
    password: string | undefined;
    reason: string | undefined;
}

export interface DepositDto {
    id: string;
    sender: SenderDto;
    image: string;
    price: number;
    postId: string;
    createdAt: string;
    status: DepositStatus;
    notes: string | undefined;
}

export interface DepositDtoPaginationResponse {
    count: number;
    data: DepositDto[] | undefined;
}

export interface DepositDtoPaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: DepositDtoPaginationResponse;
}

export interface DepositDtoResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: DepositDto;
}

export type DepositStatus = 0 | 1 | 2;

export type DiscountType = 0 | 1;

export interface EditNotaryCommand {
    id: string;
    name: string | undefined;
    url: string | undefined;
    description: string | undefined;
}

export interface EditPostCommand {
    title: string | undefined;
    property: CreatePropertyCommand;
    id: string;
}

export interface EditProfileCommand {
    fullName: string | undefined;
    areasOfInterest: string[] | undefined;
    falLicense: string | undefined;
    idCard: string | undefined;
    commercialRegistrationNumber: string | undefined;
}

export interface EditPropertyCommand {
    id: string;
    nameEn: string;
    nameAr: string;
    icon: string;
    descriptionEn: string | undefined;
    descriptionAr: string | undefined;
    isActive: boolean;
    propertyFields: PropertyTypeFieldsDto[] | undefined;
}

export interface ExitGroupCommand {
    groupId: string;
}

export interface ExtendSubscriptionCommand {
    subscriptionId: string;
    newEndDate: string;
}

export interface GetAccountByIdResponse {
    id: string;
    role: string;
    fullName: string;
    phoneNumber: string;
    falLicense: string | undefined;
    idCard: string | undefined;
    commercialRegistrationNumber: string | undefined;
    isActive: boolean;
    createdAt: string;
    provinces: ProvincesDto[] | undefined;
}

export interface GetAccountByIdResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetAccountByIdResponse;
}

export interface GetAdByIdQueryResponse {
    title: string;
    description: string | undefined;
    advertiser: AdvertiserDto;
    adPlacement: AdPlacement;
    image: string;
    url: string;
    startDate: string;
    endDate: string;
    userTypeTarget: UserTypeTarget;
    id: string;
    status: AdStatus;
    provinces: AdProvinceDto[] | undefined;
}

export interface GetAdByIdQueryResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetAdByIdQueryResponse;
}

export interface GetAdDto {
    id: string;
    title: string;
    image: string;
    url: string;
}

export interface GetAdDtoListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetAdDto[] | undefined;
}

export interface GetAdPerformanceHistoryResponse {
    date: string;
    views: number;
    clicks: number;
}

export interface GetAdPerformanceHistoryResponseListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetAdPerformanceHistoryResponse[] | undefined;
}

export interface GetAdPerformanceResponse {
    readonly totalViews: number;
    readonly totalClicks: number;
    readonly ctr: number;
    views: AdMetricDto;
    clicks: AdMetricDto;
    topRegion: TopRegionPerformanceDto;
    regionsPerformance: RegionPerformanceDto[];
}

export interface GetAdPerformanceResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetAdPerformanceResponse;
}

export interface GetAdsQueryResponse {
    title: string;
    description: string | undefined;
    advertiser: AdvertiserDto;
    adPlacement: AdPlacement;
    image: string;
    url: string;
    startDate: string;
    endDate: string;
    userTypeTarget: UserTypeTarget;
    id: string;
    status: AdStatus;
    provinces: string[] | undefined;
}

export interface GetAdsQueryResponsePaginationResponse {
    count: number;
    data: GetAdsQueryResponse[] | undefined;
}

export interface GetAdsQueryResponsePaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetAdsQueryResponsePaginationResponse;
}

export interface GetGroupBasicDto {
    id: string;
    title: string;
    image: string;
    referenceNumber: number;
    status: GroupStatus;
    membersCount: number;
    createdAt: string;
}

export interface GetGroupBasicDtoPaginationResponse {
    count: number;
    data: GetGroupBasicDto[] | undefined;
}

export interface GetGroupBasicDtoPaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetGroupBasicDtoPaginationResponse;
}

export interface GetGroupDetailDto {
    id: string;
    title: string;
    image: string;
    referenceNumber: number;
    status: GroupStatus;
    membersCount: number;
    createdAt: string;
    postId: string;
    members: GetGroupMemberDto[] | undefined;
}

export interface GetGroupDetailDtoResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetGroupDetailDto;
}

export interface GetGroupMemberDto {
    id: string;
    fullName: string;
    phoneNumber: string;
    role: GroupMemberRole;
    level: number | undefined;
    commission: number | undefined;
    hasLeft: boolean;
}

export interface GetHomePostsQuery {
    pageNumber: number;
    pageSize: number;
    propertyTypeId: string | undefined;
    provinceIds: string[] | undefined;
    propertyStatus: PropertyStatus;
    price: DecimalNullableRangeFilter;
    area: DecimalNullableRangeFilter;
    createdAt: DateTimeNullableRangeFilter;
    sortByDate: SortOrder;
    sortByPrice: SortOrder;
    propertyFields: IBaseFieldFilter[] | undefined;
    title: string | undefined;
    publisherType: PublisherType;
}

export interface GetMyPostsQuery {
    pageNumber: number;
    pageSize: number;
    propertyTypeId: string | undefined;
    provinceIds: string[] | undefined;
    propertyStatus: PropertyStatus;
    price: DecimalNullableRangeFilter;
    area: DecimalNullableRangeFilter;
    createdAt: DateTimeNullableRangeFilter;
    sortByDate: SortOrder;
    sortByPrice: SortOrder;
    propertyFields: IBaseFieldFilter[] | undefined;
    title: string | undefined;
    isRepost: boolean | undefined;
}

export interface GetMySavedPostsQuery {
    pageNumber: number;
    pageSize: number;
    propertyTypeId: string | undefined;
    provinceIds: string[] | undefined;
    propertyStatus: PropertyStatus;
    price: DecimalNullableRangeFilter;
    area: DecimalNullableRangeFilter;
    createdAt: DateTimeNullableRangeFilter;
    sortByDate: SortOrder;
    sortByPrice: SortOrder;
    propertyFields: IBaseFieldFilter[] | undefined;
    title: string | undefined;
}

export interface GetNotariesQueryResponse {
    id: string;
    name: string | undefined;
    url: string | undefined;
    description: string | undefined;
}

export interface GetNotariesQueryResponseListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetNotariesQueryResponse[] | undefined;
}

export interface GetPackagesResponse {
    id: string;
    name: string;
    price: number;
    monthlyDuration: number;
    postsPerMonth: number;
    repostsPerMonth: number;
    promotionCredits: number;
    hasTrustedBadge: boolean;
    showPromotionAnalytics: boolean;
    autoRenewal: boolean;
}

export interface GetPackagesResponseListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPackagesResponse[] | undefined;
}

export interface GetPostBasicDto {
    id: string;
    title: string;
    posterInfo: PosterBasicInfo;
    status: PropertyStatus;
    isRepost: boolean;
    isSaved: boolean;
    isPromoted: boolean;
    hasTrustedBadge: boolean;
    postLevel: number;
    createdAt: string;
    property: GetPropertyBasicDto;
}

export interface GetPostBasicDtoPaginationResponse {
    count: number;
    data: GetPostBasicDto[] | undefined;
}

export interface GetPostBasicDtoPaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPostBasicDtoPaginationResponse;
}

export interface GetPostDetailDto {
    id: string;
    title: string;
    posterInfo: PosterBasicInfo;
    status: PropertyStatus;
    isRepost: boolean;
    isSaved: boolean;
    isPromoted: boolean;
    hasTrustedBadge: boolean;
    postLevel: number;
    createdAt: string;
    property: GetPropertyDetailDto;
    deposit: DepositDto;
}

export interface GetPostDetailDtoResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPostDetailDto;
}

export interface GetPostDetailsResponse {
    id: string;
    posterId: string;
    postTitle: string;
    posterName: string;
    status: PropertyStatus;
    propertyId: string;
    propertyTypeNameAr: string;
    propertyTypeNameEn: string;
    createdAt: string;
    price: number;
    area: number;
    provinceNameAr: string;
    provinceNameEn: string;
    regionNameAr: string;
    regionNameEn: string;
    posterPhone: string;
    googleMapsLocation: GoogleMapsLocation;
    propertyDeed: string | undefined;
    ownersIdImage: string | undefined;
    agentsIdImage: string | undefined;
    powerOfAttorneyImage: string | undefined;
    images: string[] | undefined;
    propertyFieldValues: PropertyFieldWithValue[] | undefined;
}

export interface GetPostDetailsResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPostDetailsResponse;
}

export interface GetPostTreeResponse {
    posterId: string;
    postId: string;
    posterName: string;
    posterPhone: string;
    postLevel: number;
    reposts: GetPostTreeResponse[] | undefined;
}

export interface GetPostTreeResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPostTreeResponse;
}

export interface GetPostsResponse {
    id: string;
    posterId: string;
    postTitle: string;
    posterName: string;
    status: PropertyStatus;
    propertyId: string;
    propertyTypeNameAr: string;
    propertyTypeNameEn: string;
    createdAt: string;
    price: number;
    area: number;
    provinceNameAr: string;
    provinceNameEn: string;
    regionNameAr: string;
    regionNameEn: string;
}

export interface GetPostsResponsePaginationResponse {
    count: number;
    data: GetPostsResponse[] | undefined;
}

export interface GetPostsResponsePaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPostsResponsePaginationResponse;
}

export interface GetPropertyBasicDto {
    id: string;
    propertyType: GetPropertyTypeDto;
    posterType: PosterType;
    ownerId: string;
    googleMapsLocation: GoogleMapsLocation;
    province: GetProvinceBasicDto;
    area: number;
    price: number;
    negotiable: boolean;
    propertyDeed: string | undefined;
    ownersIdImage: string | undefined;
    agentsIdImage: string | undefined;
    powerOfAttorneyImage: string | undefined;
    images: string[] | undefined;
}

export interface GetPropertyByIdQueryResponse {
    id: string;
    nameEn: string;
    nameAr: string;
    icon: string;
    descriptionEn: string | undefined;
    descriptionAr: string | undefined;
    isActive: boolean;
    propertyFields: PropertyTypeFieldsDto[] | undefined;
}

export interface GetPropertyByIdQueryResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPropertyByIdQueryResponse;
}

export interface GetPropertyDetailDto {
    id: string;
    propertyType: GetPropertyTypeDto;
    posterType: PosterType;
    ownerId: string;
    googleMapsLocation: GoogleMapsLocation;
    province: GetProvinceBasicDto;
    area: number;
    price: number;
    negotiable: boolean;
    propertyDeed: string | undefined;
    ownersIdImage: string | undefined;
    agentsIdImage: string | undefined;
    powerOfAttorneyImage: string | undefined;
    images: string[] | undefined;
    propertyFieldValues: GetPropertyFieldValueDto[] | undefined;
}

export interface GetPropertyFieldDto {
    id: string;
    inputEnum: InputEnum;
    name: string;
    description: string | undefined;
    isMandatory: boolean;
    maxValue: any | undefined;
    minValue: any | undefined;
    options: GetPropertyTypeFieldOptionDto[] | undefined;
}

export interface GetPropertyFieldDtoListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPropertyFieldDto[] | undefined;
}

export interface GetPropertyFieldValueDto {
    id: string;
    inputEnum: InputEnum;
    name: string;
    description: string | undefined;
    isMandatory: boolean;
    maxValue: any | undefined;
    minValue: any | undefined;
    options: GetPropertyTypeFieldOptionDto[] | undefined;
    value: any | undefined;
}

export interface GetPropertyFilterResponse {
    id: string;
    name: string;
    icon: string;
    description: string | undefined;
    propertyFields: GetPropertyFieldDto[] | undefined;
}

export interface GetPropertyFilterResponseListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPropertyFilterResponse[] | undefined;
}

export interface GetPropertyTypeDto {
    id: string;
    name: string;
    icon: string;
    description: string | undefined;
}

export interface GetPropertyTypeDtoPaginationResponse {
    count: number;
    data: GetPropertyTypeDto[] | undefined;
}

export interface GetPropertyTypeDtoPaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPropertyTypeDtoPaginationResponse;
}

export interface GetPropertyTypeFieldOptionDto {
    id: string;
    option: string;
}

export interface GetPropertyTypesWebQueryResponse {
    id: string;
    name_En: string;
    name_Ar: string;
    offersCount: number;
    isActive: boolean;
    createdAt: string;
    modifiedAt: string;
}

export interface GetPropertyTypesWebQueryResponsePaginationResponse {
    count: number;
    data: GetPropertyTypesWebQueryResponse[] | undefined;
}

export interface GetPropertyTypesWebQueryResponsePaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetPropertyTypesWebQueryResponsePaginationResponse;
}

export interface GetProvinceBasicDto {
    id: string;
    name: string;
    regionId: string;
    regionName: string;
}

export interface GetReceivedDepositsResponse {
    title: string;
    image: string;
    deposits: DepositDto[] | undefined;
}

export interface GetReceivedDepositsResponsePaginationResponse {
    count: number;
    data: GetReceivedDepositsResponse[] | undefined;
}

export interface GetReceivedDepositsResponsePaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetReceivedDepositsResponsePaginationResponse;
}

export interface GetReportsResponse {
    id: string;
    postId: string;
    reporterId: string;
    publisherId: string;
    isResolved: boolean;
    postTitle: string;
    publisherName: string;
    reporterName: string;
    reportReason: string;
    reportDate: string;
}

export interface GetReportsResponsePaginationResponse {
    count: number;
    data: GetReportsResponse[] | undefined;
}

export interface GetReportsResponsePaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetReportsResponsePaginationResponse;
}

export interface GetSentDepositsResponse {
    title: string;
    image: string;
    deposit: DepositDto;
}

export interface GetSentDepositsResponsePaginationResponse {
    count: number;
    data: GetSentDepositsResponse[] | undefined;
}

export interface GetSentDepositsResponsePaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetSentDepositsResponsePaginationResponse;
}

export interface GetSubscribedUsersResponse {
    id: string;
    user: SubscribedUserDto;
    packageName: string;
    startDate: string;
    endDate: string | undefined;
    autoRenewal: boolean;
    readonly isActive: boolean;
    paymentInfo: PaymentInfo;
}

export interface GetSubscribedUsersResponsePaginationResponse {
    count: number;
    data: GetSubscribedUsersResponse[] | undefined;
}

export interface GetSubscribedUsersResponsePaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: GetSubscribedUsersResponsePaginationResponse;
}

export interface GetUserPostQuery {
    pageNumber: number;
    pageSize: number;
    propertyTypeId: string | undefined;
    provinceIds: string[] | undefined;
    propertyStatus: PropertyStatus;
    price: DecimalNullableRangeFilter;
    area: DecimalNullableRangeFilter;
    createdAt: DateTimeNullableRangeFilter;
    sortByDate: SortOrder;
    sortByPrice: SortOrder;
    propertyFields: IBaseFieldFilter[] | undefined;
    userId: string;
    title: string | undefined;
}

export interface GoogleMapsLocation {
    latitude: number;
    longitude: number;
}

export type GroupMemberRole = 0 | 1 | 2 | 3;

export type GroupStatus = 0 | 1 | 2;

export interface IBaseFieldFilter {
    fieldId: string;
    inputEnum: InputEnum;
}

export interface IHomePageItem {
}

export interface IHomePageItemPaginationResponse {
    count: number;
    data: IHomePageItem[] | undefined;
}

export interface IHomePageItemPaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: IHomePageItemPaginationResponse;
}

export type InputEnum = 0 | 1 | 2 | 3 | 4 | 5 | 6;

export interface Int32Result {
    succeeded: boolean;
    messages: string[] | undefined;
    data: number;
}

export interface LoginAdminCommand {
    userNameOrEmail: string | undefined;
    password: string | undefined;
}

export interface LoginUserCommand {
    phoneNumber: string | undefined;
    password: string | undefined;
}

export interface ManageOfferStatusCommand {
    postId: string;
    status: PropertyStatus;
    rejectionReason: string | undefined;
}

export interface ManageReportStatusCommand {
    id: string;
    isResolved: boolean;
}

export interface MobileCommentDto {
    id: string;
    content: string;
    commenter: CommenterDto;
    createdAt: string;
}

export interface MobileCommentDtoResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: MobileCommentDto;
}

export interface MobileCommentWithRepliesDto {
    id: string;
    content: string;
    commenter: CommenterDto;
    createdAt: string;
    replies: MobileCommentDto[] | undefined;
}

export interface MobileCommentWithRepliesDtoPaginationResponse {
    count: number;
    data: MobileCommentWithRepliesDto[] | undefined;
}

export interface MobileCommentWithRepliesDtoPaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: MobileCommentWithRepliesDtoPaginationResponse;
}

export interface MobileCommentWithRepliesDtoResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: MobileCommentWithRepliesDto;
}

export interface MyPromotedPostsResponse {
    id: string;
    title: string;
    propertyTypeName: string;
    image: string;
    createdAt: string;
    adsCount: number;
    adsViews: number;
    adsClicks: number;
    readonly postCTR: number;
}

export interface MyPromotedPostsResponsePaginationResponse {
    count: number;
    data: MyPromotedPostsResponse[] | undefined;
}

export interface MyPromotedPostsResponsePaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: MyPromotedPostsResponsePaginationResponse;
}

export type OTPReason = 0 | 1 | 2 | 3;

export interface OptionValue {
    value: string;
    valueEn: string | undefined;
}

export interface PackageInfo {
    name: string;
    price: number;
}

export type PackageType = 0 | 1;

export interface PaymentInfo {
    amount_Paid: number;
    payment_Method: string | undefined;
    transaction_Id: string | undefined;
}

export interface PaymentInfoDto {
    amount_Paid: number;
    payment_Method: string | undefined;
    transaction_Id: string | undefined;
}

export type PerformanceInterval = 0 | 1 | 2;

export interface PostPromotion {
    id: string;
    startDate: string;
    endDate: string;
    isActive: boolean;
    views: number;
    clicks: number;
    readonly promotionCTR: number;
}

export interface PostPromotionsResponse {
    id: string;
    title: string;
    propertyTypeName: string;
    image: string;
    createdAt: string;
    adsCount: number;
    adsViews: number;
    adsClicks: number;
    readonly postCTR: number;
    promotions: PostPromotion[] | undefined;
}

export interface PostPromotionsResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: PostPromotionsResponse;
}

export interface PosterBasicInfo {
    id: string;
    fullName: string;
    phoneNumber: string | undefined;
}

export type PosterType = 0 | 1 | 2;

export type PromotionSortOptions = 0 | 1 | 2 | 3;

export interface PropertyFieldOptionDto {
    optionEn: string;
    optionAr: string;
}

export interface PropertyFieldWithValue {
    fieldNameAr: string;
    fieldNameEn: string;
    values: OptionValue[];
}

export interface PropertyFieldsDto {
    nameEn: string;
    nameAr: string;
    inputEnum: InputEnum;
    descriptionEn: string | undefined;
    descriptionAr: string | undefined;
    isFilterable: boolean;
    isMandatory: boolean;
    order: number;
    maxValue: string | undefined;
    minValue: string | undefined;
    options: PropertyFieldOptionDto[] | undefined;
}

export type PropertyStatus = 0 | 1 | 2 | 3 | 4 | 5;

export interface PropertyTypeFieldOptionDto {
    id: string;
    optionEn: string;
    optionAr: string;
}

export interface PropertyTypeFieldsDto {
    id: string;
    nameEn: string;
    nameAr: string;
    inputEnum: InputEnum;
    descriptionEn: string | undefined;
    descriptionAr: string | undefined;
    isFilterable: boolean;
    isMandatory: boolean;
    order: number;
    maxValue: string | undefined;
    minValue: string | undefined;
    options: PropertyTypeFieldOptionDto[] | undefined;
}

export interface PropertyTypesDropdownResponse {
    id: string;
    nameAr: string;
    nameEn: string;
}

export interface PropertyTypesDropdownResponseListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: PropertyTypesDropdownResponse[] | undefined;
}

export interface ProvinceDto {
    id: string;
    name: string;
}

export interface ProvinceForUser {
    id: string;
    name: string | undefined;
}

export interface ProvincePerformanceDto {
    name_Ar: string;
    name_En: string;
    views: number;
    clicks: number;
}

export interface ProvinceWebDto {
    id: string;
    nameEn: string;
    nameAr: string;
}

export interface ProvincesDto {
    id: string;
    nameEn: string;
    nameAr: string;
}

export type PublisherType = 0 | 1 | 2;

export interface RefreshTokenCommand {
    refreshToken: string | undefined;
}

export interface RegionForUser {
    id: string;
    name: string | undefined;
    provinces: ProvinceForUser[] | undefined;
}

export interface RegionPerformanceDto {
    name_Ar: string;
    name_En: string;
    provinces: ProvincePerformanceDto[] | undefined;
}

export interface RegisterCommandResponse {
    phoneNumber: string | undefined;
    otpResult: Int32Result;
}

export interface RegisterCommandResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: RegisterCommandResponse;
}

export interface RegistrationCommand {
    role: UserRole;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    password: string | undefined;
    areasOfInterest: string[] | undefined;
    falLicense: string | undefined;
    idCard: string | undefined;
    commercialRegistrationNumber: string | undefined;
}

export interface RejectDepositCommand {
    id: string;
    isSold: boolean;
    rejectionReason: string | undefined;
}

export interface ResetPasswordCommand {
    newPassword: string | undefined;
    newPasswordConfirmation: string | undefined;
}

export interface SendDepositCommand {
    post_Id: string;
    price: number;
    image: string | undefined;
    notes: string | undefined;
}

export interface SendOTPCommand {
    phoneNumber: string | undefined;
    otpReason: OTPReason;
}

export interface SendOTPCommandResponse {
    phoneNumber: string | undefined;
    susbentionTime: number;
}

export interface SendOTPCommandResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: SendOTPCommandResponse;
}

export interface SenderDto {
    id: string;
    fullName: string;
    phoneNumber: string | undefined;
}

export type SortOrder = 0 | 1;

export type SortingOptions = 0 | 1 | 2 | 3 | 4 | 5;

export interface StringListResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: string[] | undefined;
}

export interface StringResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: string | undefined;
}

export interface SubscribeCommand {
    code: string | undefined;
    package_Id: string;
    payment_Info: PaymentInfoDto;
    auto_Renewal: boolean;
}

export interface SubscribedUserDto {
    id: string;
    fullName: string;
    phoneNumber: string | undefined;
}

export interface ToggleSavedPostCommand {
    postId: string;
}

export interface TokenDto {
    accessToken: string | undefined;
    refreshToken: string | undefined;
    expires: string;
}

export interface TokenDtoResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: TokenDto;
}

export interface TopRegionPerformanceDto {
    name_Ar: string;
    name_En: string;
    views: number;
}

export interface Unit {
}

export interface UnitResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: Unit;
}

export interface UpdateAccountCommand {
    id: string;
    fullName: string;
    falLicense: string | undefined;
    commercialRegistrationNumber: string | undefined;
    areasOfInterest: string[] | undefined;
}

export interface UpdateAdCommand {
    title: string;
    description: string | undefined;
    advertiser: AdvertiserDto;
    adPlacement: AdPlacement;
    image: string;
    url: string;
    startDate: string;
    endDate: string;
    userTypeTarget: UserTypeTarget;
    provinces: string[] | undefined;
    id: string;
    status: AdStatus;
}

export interface UpdateDepositCommand {
    id: string;
    price: number;
    image: string | undefined;
    notes: string | undefined;
}

export interface UserProfileResponse {
    id: string;
    idCard: string | undefined;
    fullName: string | undefined;
    phoneNumber: string | undefined;
    falLicense: string | undefined;
    commercialRegistrationNumber: string | undefined;
    packageInfo: PackageInfo;
    areasOfInterest: RegionForUser[] | undefined;
}

export interface UserProfileResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: UserProfileResponse;
}

export type UserRole = 0 | 1 | 2 | 3;

export type UserTypeTarget = 0 | 1 | 2;

export interface VerifyOTPCommand {
    phoneNumber: string | undefined;
    otp: number;
    otpReason: OTPReason;
}

export interface VerifyOTPResponse {
    isVerified: boolean;
    suspensionTime: number;
    token: TokenDto;
}

export interface VerifyOTPResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: VerifyOTPResponse;
}

export interface WebCommentDto {
    id: string;
    content: string;
    commenter: CommenterDto;
    createdAt: string;
}

export interface WebCommentWithRepliesDto {
    id: string;
    content: string;
    commenter: CommenterDto;
    createdAt: string;
    replies: WebCommentDto[] | undefined;
}

export interface WebCommentWithRepliesDtoPaginationResponse {
    count: number;
    data: WebCommentWithRepliesDto[] | undefined;
}

export interface WebCommentWithRepliesDtoPaginationResponseResult {
    succeeded: boolean;
    messages: string[] | undefined;
    data: WebCommentWithRepliesDtoPaginationResponse;
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new ApiException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}